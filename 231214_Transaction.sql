/* 20231214
트랜잭션
    - 데이터베이스의 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 논리적인 작업의 단위
      ex) 홍길동이 이순신에게 100만원을 이체하는 경우
          1. 홍길동의 계좌에서 잔액을 100만원 감소시킨다. - UPDATE 작업
          2. 이순신의 계좌에서 잔액을 100만원 증가시킨다. - UPDATE 작업
          3. 홍길동의 최근 이체내역에 이순신에게 100만원 송금한 내용을 추가한다. - INSERT 작업
          
          * 논리적인 작업의 단위(그룹, 묶음, 연산들) = 감소 UPDATE + 증가 UPDATE + 추가 INSERT
          * 논리적인 작업의 단위를 구성하는 모든 SQL 명령이 성공적으로 완료되어야 하나의 작업 단위가
            완료된 것이고, 이 경우 데이터베이스에 반영시킴

트랜잭션 관련 명령어
    COMMIT
        - 논리적인 작업 단위를 구성하는 모든 작업이 성공적으로 완료되었을 때,
          데이터베이스의 트랜잭션 관리자에게
          해당 작업 단위 내에서 실행했던 처리 결과를 영구적으로 데이터베이스에 반영시키게 함
    ROLLBACK
        - 논리적인 작업 단위를 구성하는 작업 줄에서 오류가 발생했을 때,
          데이터베이스의 트랜잭션 관리자에게
          해당 작업 단위 내에서 실행했던 처리 결과의 데이터베이스 반영을 취소시키게 함
          
    트랜잭션의 시작과 종료
        1. 트랜잭션의 시작
          - 첫번째 DML 명령문이 실행될 때 새로운 트랜잭션이 시작됨
          - COMMIT, ROLLBACK 명령 실행 시 기존 트랜잭션 종료 후 새로운 트랜잭션이 시작됨
        2. 트랜잭션의 종료
          - COMMIT, ROLLBACK 명령 실행 시 기존 트랜잭션이 종료됨
          - DBMS에 시스템 장애가 발생할 때 AUTO-ROLLBACK이 실행되면서 트랜잭션이 종료됨
          
트랜잭션의 성질
    1. 원자성: A(Atomicity)
        - 한 트랜잭션 내의 연산들은 모두 성공하거나, 전부 실패되는 성질이 있음
          즉, 부분적인 성공을 허용하지 않음
    2. 일관성: C(Consistency)
        - 트랜잭션이 종료되는 데이터베이스의 데이터는 일관성을 유지해야 함
          트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 함
    3. 고립성: I(Isolation)
        - 모든 트랜잭션은 다른 트랜잭션으로부터 독립적으로 처리됨
    4. 지속성: D(Durability)
        - 트랜잭션이 성공적으로 수행되었다면 데이터베이스에 영구적으로 반영됨
    
트랜잭션 관련 명령어 실행 시 발생하는 일
    1. COMMIT 실행 시
        - 데이터베이스에 데이터를 영구적으로 반영시킴
        - 트랜잭션 실행 이전 상태를 완전히 상실함(이전 상태로 되돌아갈 수 없음)
        - 변경된 레코드(데이터 행)의 LOCK이 해제되어 다른 사용자(트랜잭션)가 변경할 수 있게 됨
    2. ROLLBACK 실행 시
        - 트랜잭션 실행 이전 상태로 데이터의 상태를 복구시킴
        - 변경된 레코드(데이터 행)의 LOCK이 해제되어 다른 사용자(트랜잭션)가 변경할 수 있게 됨
*/

------------------------------------------------------------ 트랜잭션1 시작
UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT - 1000000
WHERE
    NO = 10;                       -- 트랜잭션1의 연산
    
UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT + 1000000
WHERE
    NO = 20;                       -- 트랜잭션1의 연산

INSERT INTO HISTORIES
VALUES (10, 20, 1000000, SYSDATE); -- 트랜잭션1의 연산

COMMIT;                            -- 트랜잭션1의 모든 연산이 오류없이 실행되었기 때문에
                                   -- 트랜잭션관리자에게 트랜잭션1의 처리결과를 영구적으로 데이터베이스에 반영시키도록 함
------------------------------------------------------------ 트랜잭션1 종료
------------------------------------------------------------ 트랜잭션2 시작
UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT - 50000      -- 트랜잭션2의 연산
WHERE
    NO = 70;

UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT + 50000      -- 트랜잭션2의 연산
WHERE
    NO = 120;
    
INSERT INTO HISTORIES
VALUES (70, 120, 50000);           -- 트랜잭션2의 연산

ROLLBACK;                          -- 트랜잭션2의 INSERT 작업중 오류가 발생함
                                   -- 트랜잭션관리자에게 트랜잭션2의 처리결과를 모두 취소시키도록 함
------------------------------------------------------------ 트랜잭션2 종료
------------------------------------------------------------ 트랜잭션3 시작

